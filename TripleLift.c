#pragma config(Sensor, dgtl1,  liftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  liftTouch,      sensorTouch)
#pragma config(Sensor, dgtl4,  sonar,          sensorSONAR_inch)
#pragma config(Sensor, dgtl10, LEDR,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, LEDY,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, LEDG,           sensorLEDtoVCC)
#pragma config(Motor,  port1,           clawWrist,     tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port2,           claw,          tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port3,           liftMotor1,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           wheelFrontRight, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           wheelBackRight, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           wheelFrontLeft, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           wheelBackLeft, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           clawLift,      tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port9,           liftMotor2,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////////////////////////////////////////////
//								--= TRIPLE LIFT BOT =--								//
//////////////////////////////////////////////////////////////////////////////////////

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

//////////////////
// DEPENDENCIES //
//////////////////

#include "BlinkModule.c"
#include "BatteryModule.c"
#include "DriverControlModule.c"
#include "PIDLoopModule.c"
#include "AutonomousModule.c"

//// PRE-AUTONOMOUS SETUP ////
void pre_auton()
{
	writeDebugStreamLine("[Mode]: Setting up the robot...");
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = false; // This must be disabled to allow the PID Loop.

	// Initialize the driver configuration and button "event" handler.
	startTask(buttonHandler);

	// Start the blink debug handler.
	startTask(blink);

	// Start the battery monitor.
	startTask(batteryMonitor);

	// Reset the lift to the bottom position.
	if (SensorType[liftTouch] != sensorNone) {
		motor[liftMotor1] = -64;
		motor[liftMotor2] = -64;
		startBlinkTask(Info, Medium);
		while (SensorValue[liftTouch] != 1) {
			// Wait...
			wait1Msec(10);
		}
		motor[liftMotor1] = 0;
		motor[liftMotor2] = 0;

		// Set the encoder to 0 for the PID loop.
		SensorValue[liftEncoder] = 0;
		wait1Msec(500);
		clearBlinkTasks();
	}

	// Startup the PID system.
	startTask(pidController);
	writeDebugStreamLine("[Mode]: Setup complete!");
}

//// AUTONOMOUS MODE ////
task autonomous()
{
	/*short id = startBlinkTask(Info, Slow);
	writeDebugStreamLine("[Mode]: Autonomous mode enabled!");
	float sonarAverage = 0;
	repeat (10) {
		sonarAverage += SensorValue[sonar];
		wait1Msec(10);
	}
	sonarAverage = sonarAverage / 10;

	if (sonarAverage <= 25) {
		// Placed further from autoloader.
		strafe(-127); // Move up to the corner.
		while (SensorValue[sonar] > 2) {
			wait1Msec(10);
		}
		halt();
		rotate(-127, 1); // Face the wall.
		strafe(-127, 1); // Meet the autoloader.
		wait1Msec(3000); // Grab the tower segment.
		rotate(-127, 2); // Face the tower base.
		wait1Msec(3000); // Place the tower base.
		rotate(127, 2);  // Face the wall.
		strafe(-127);	 // Meet the corner.
		while (SensorValue[sonar] > 2) {
			wait1Msec(10);
		}
		halt();
		rotate(-127, 3); // Face opposite the wall.
		strafe(127); // Return to base.
		while (SensorValue[sonar] < 25) {
			wait1Msec(10);
		}
		halt();
	} else {
		// Placed close to the autoloader. Life is easy!
		rotate(127, 2); // Turn all the way around.
		strafe(-64, 1);
		wait1Msec(3000); // Grab the tower segment.
		rotate(127, 2);
		wait1Msec(3000); // Place the tower segment.
		strafe(-64, 1);
	}
	writeDebugStreamLine("[Mode]: Autonomous mode disabled!");
	stopBlinkTask(id);*/
}

//// USER CONTROL MODE ////
task usercontrol()
{
	writeDebugStreamLine("[Mode]: User Control mode enabled!");
	while (true) {
		// Claw Control
		if (vexRT[DRIVER_CONFIG[ClawClamp]] == true) {
			// Toggle the claw power.
			motor[claw] = -1 * motor[claw];
		}
		// Claw Wrist
		if (DRIVER_CONFIG[ClawWristUp] != UNASSIGNED && vexRT[DRIVER_CONFIG[ClawWristUp]] == true) {
			motor[clawWrist] = 127;
		} else if (DRIVER_CONFIG[ClawWristDown] != UNASSIGNED && vexRT[DRIVER_CONFIG[ClawWristDown]] == true) {
			motor[clawWrist] = -127;
		} else if (DRIVER_CONFIG[ClawWristJoy] != UNASSIGNED) {
			motor[clawWrist] = vexRT[DRIVER_CONFIG[ClawWristJoy]];
		}
		// Claw Lift
		if (DRIVER_CONFIG[ClawLiftUp] != UNASSIGNED && vexRT[DRIVER_CONFIG[ClawLiftUp]] == true) {
			motor[clawLift] = 127;
		} else if (DRIVER_CONFIG[ClawLiftDown] != UNASSIGNED && vexRT[DRIVER_CONFIG[ClawLiftDown]] == true) {
			motor[clawLift] = -127;
		} else if (DRIVER_CONFIG[ClawLiftJoy] != UNASSIGNED) {
			motor[clawLift] = vexRT[DRIVER_CONFIG[ClawLiftJoy]];
		}

		// Lift Control
		if (DRIVER_CONFIG[LiftUp] != UNASSIGNED && vexRT[DRIVER_CONFIG[LiftUp]] == true) {
			// Add or subtract the PID target height.
			if (PID_ENABLED)
				PID_target += PID_CONTROL_INCREMENTER_UP;
			else {
				// If the PID loop is disabled, set the motor power manually.
				motor[liftMotor1] = 127;
				motor[liftMotor2] = 127;
			}
		} else if (DRIVER_CONFIG[LiftDown] != UNASSIGNED && vexRT[DRIVER_CONFIG[LiftDown]] == true) {
			if (PID_ENABLED)
				PID_target -= PID_CONTROL_INCREMENTER_DOWN;
			else {
				motor[liftMotor1] = -64;
				motor[liftMotor2] = -64;
			}
		} else if (vexRT[DRIVER_CONFIG[LiftJoy]] != UNASSIGNED) {
			// Get the power value view the joystick, then apply the proportional power to the lift.
			int power = vexRT[DRIVER_CONFIG[LiftJoy]];
			if (PID_ENABLED) {
				PID_target += power / 4;
			}
			else {
				motor[liftMotor1] = power;
				motor[liftMotor2] = power;
			}
		} else if (!PID_ENABLED) {
			motor[liftMotor1] = 0;
			motor[liftMotor2] = 0;
		}
		// Lift Macros
		if (ControllerButtonsDown[LiftTopMacro] == true) {
			PID_target = PID_TARGET_MAX;
			ControllerButtonsDown[LiftTopMacro] = false;
		} else if (ControllerButtonsDown[LiftBottomMacro] == true) {
			PID_target = 0;
			ControllerButtonsDown[LiftBottomMacro] = false;
		}

		if (DRIVER_CONFIG[MecanumRotate] == UNASSIGNED) {
			// 4 joystick drive enabled.
			int threshold = 20;
			int RX = vexRT[DRIVER_CONFIG[MecanumRightStrafe]];
			int RY = vexRT[DRIVER_CONFIG[MecanumRightNormal]];
			int LX = vexRT[DRIVER_CONFIG[MecanumLeftStrafe]];
			int LY = vexRT[DRIVER_CONFIG[MecanumLeftNormal]];

			if (abs(RX) < threshold) {
				// Straight
				motor[wheelFrontRight] = RY;
				motor[wheelBackRight] = RY;
			} else if (RX > threshold) {
				// Right
				motor[wheelFrontRight] = RX;
				motor[wheelBackRight] = -RX;
			} else if (RX < -threshold) {
				// Left
				motor[wheelFrontRight] = RX;
				motor[wheelBackRight] = -RX;
			} else {
				// Stop
				motor[wheelFrontRight] = 0;
				motor[wheelBackRight] = 0;
			}

			if (abs(LX) < threshold) {
				// Straight
				motor[wheelFrontLeft] = LY;
				motor[wheelBackLeft] = LY;
			} else if (LX > threshold) {
				// Right
				motor[wheelFrontLeft] = -LX;
				motor[wheelBackLeft] = LX;
			} else if (LX < -threshold) {
				// Left
				motor[wheelFrontLeft] = -LX;
				motor[wheelBackLeft] = LX;
			} else {
				// Stop
				motor[wheelFrontLeft] = 0;
				motor[wheelBackLeft] = 0;
			}
		} else {
			// 3 joystick drive enabled.
			motor[wheelFrontRight] 	= vexRT[DRIVER_CONFIG[MecanumRightNormal]]
				- vexRT[DRIVER_CONFIG[MecanumRotate]]
				+ vexRT[DRIVER_CONFIG[MecanumRightStrafe]];
   			motor[wheelBackRight] 	= vexRT[DRIVER_CONFIG[MecanumRightNormal]]
   				- vexRT[DRIVER_CONFIG[MecanumRotate]]
   				- vexRT[DRIVER_CONFIG[MecanumRightStrafe]];
    		motor[wheelFrontLeft] 	= vexRT[DRIVER_CONFIG[MecanumLeftNormal]]
    			+ vexRT[DRIVER_CONFIG[MecanumRotate]]
    			- vexRT[DRIVER_CONFIG[MecanumLeftStrafe]];
    		motor[wheelBackLeft] 	= vexRT[DRIVER_CONFIG[MecanumLeftNormal]]
    			+ vexRT[DRIVER_CONFIG[MecanumRotate]]
    			+ vexRT[DRIVER_CONFIG[MecanumLeftStrafe]];
		}

		// Override controls
		if (ControllerButtonsDown[PidOverride] == true) {
			// Toggle the the PID loop, then stop motors.
			PID_ENABLED = !PID_ENABLED;
			writeDebugStreamLine("PID Enabled status: %i", PID_ENABLED);
			motor[liftMotor1] = 0;
			motor[liftMotor2] = 0;
			// Indicate to the DriverControlModule that we have recieved the button press.
			ControllerButtonsDown[PidOverride] = false;
		}
	}
	writeDebugStreamLine("[Mode]: User Control mode disabled!");
}
